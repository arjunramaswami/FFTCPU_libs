# MKL FFT3d

This folder contains the code to execute 3d FFT using MKL. Currently executes
multi threaded configurations on **double precision floating point** data.  

The program and bash scripts can be used to evaluate and consolidate performance of FFT3d using MKL for different uniform sized transformations. Distinct backward or forward transformations can be executed a number of times to find the average performance using a multithreaded environment.

Link to the official [MKL FFT](https://software.intel.com/en-us/node/521955).

## Builds

### Prerequisites

`module load intel/20.0.0` : loads icc and mkl libraries. icc version loaded is 19.1.0.166, compatible with gcc 8.3.0

## Target

Double Precision multithreaded MKL FFT3d

`make` : creates an executable named `host_dp` in the MKL directory

Compiling with DEBUG macro set say, `make DEBUG=1`, prints data input.

## Execution

Running the program with `-h` to print the options available.
Options:

```bash
  -m : FFT 1st Dim Size
  -n : FFT 2nd Dim Size
  -p : FFT 3rd Dim Size

  -i : Number of iterations of the FFT computation

  -t : number of threads in a multithreaded execution
  -b : toggle backward transformation
```

### Example

```bash
  module load intel/20.0.0
  make
  ./host_dp -m 16 -n 16 -p 16
  ./host_dp -m 256 -n 256 -p 256 -i 100 -t 20
  ./host_dp -m 256 -n 256 -p 256 -i 100 -t 20 -b
```

## Interpreting Results

The output shows configuration of execution and the series of steps the program
executes followed by the consolidation of some performance metrics such as:

```bash
FFT Size    Total Runtime(ms)   Avg Runtime(ms)     Throughput(GFLOPS)
   32          30.051               0.300               23.51
```

- FFT Size is the size of the 3d FFT
- Total Runtime (milliseconds) : total amount of time to execute the given
  number of iterations.
- Avg Runtime (milliseconds) : average runtime for a single iteration of execution i.e.,
  total runtime by the number of iterations
- Throughput (GFLOPS): Calculated by *3 * 5 * N * logN / (time for one FFT)*, this is not the actual flop count rather an asymptotic measurement using the
  radix-2 Cooley Tukey algorithm.

### Important Points

- Runtime only measures the walltime of the FFT execution, not the
  initialization and plan creation. Measured using `clock_gettime` to provide
  nanosecond resolution.
- Iterations are made on the same input data, by reinitialization every iteration.

## Results

### Best Runtime and Throughput

| FFT3d Size | Best Runtime (ms) | Throughput (GFLOPS) |
|:----------:|:-----------------:|:-------------------:|
|     16     |   0.012           |     19.25           |
|     32     |   0.056           |     43.58           |
|     64     |   0.197           |    119.80           |
|     128    |   1.393           |    158.08           |
|     256    |    23.19          |     86.80           |

### Speedup with Multithreading

| FFT3d Size | Max Speedup |
|:----------:|:-----------:|
|     16     |     1.27    |
|     32     |     2.24    |
|     64     |     7.01    |
|     128    |     12.25   |
|     256    |     9.83    |

#### Notes

- Better Speedup with increase in FFT size i.e., more data
- Can one estimate the maximum speedup possible

### Details on execution

The bash file `omp_mkl_fft_run.sh` can be used to execute on NOCTUA cluster :
```
sbatch omp_mkl_fft_run.sh <array of sizes of fft3d>

sbatch omp_mkl_fft_run.sh 16 32 64
```

1. loads `mkl`

2. Sets openmp thread affinity env variables

3. Executes the application using srun on the same node from 1 to 40 threads
one after another and saves the output in distinct reports only for forward FFTs.

The bash file `create_csv.sh` can be used to create a csv output from the reports generated by the above bash file.

`./create_csv.sh <generated_report> <output.csv>

### Compilation

To compile with Intel OpenMP, link this additional flag `-qopenmp`. These are added to the Makefile.

## Input Data and Validation

Generate a discrete signal of a single specific frequency by creating N<sup>3</sup> discrete points of a cosine and sine wave. Modify the frequency by creating its harmonic (positive multiple of a fundamental frequency) for variations.

Validate by checking the particular frequency's value after transformation.

### Error Bound

Why is the error bound calculated as $5 * \log _{2}(N1*N2*N3) * DBL\_EPLISON$ ?

## Configuring FFT with MKL

- Create descriptor
  - creates a configuration for the FFT to be computed.
  - inputs : precision, data type, dim, size

- Set additional configuration values
  - number of threads, in-place / not in-place placement

- Commit Descriptor

- Initialize input to transform

- Compute either forward or backward transform